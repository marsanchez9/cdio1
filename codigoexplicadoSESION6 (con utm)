import os   #para trabjar con archivos, carpetas..
import rasterio
import numpy as np       #para trabajar con arreys num√©ricos
from scipy.ndimage import convolve #Importa la funci√≥n convolve de SciPy para aplicar filtros/convoluciones a imagenes
import geopandas as gpd
from shapely.geometry import Point, shape
from datetime import datetime
import pandas as pd
from scipy import ndimage
from rasterio.mask import mask
import json

# Carpeta on tens les imatges descarregades
base_folder = "./sentinel2_images4"
polygon_geojson_path = "/.polygon.geojson1" #ns que poner de nombre 

# Cargar pol√≠gono del GeoJSON
with open(polygon_geojson_path) as f:
    geojson_data = json.load(f)
polygon_geom = [shape(geojson_data["features"][0]["geometry"])]  # en lista, para rasterio.mask

# Kernel per detectar canvis als ve√Øns (3x3 excloent el centre), nos permite detectar lo bordes. Lo multiplicas con matriz 3x3 desde que se detecta
# un agua, sabiendo que agua = 1 y no agua = 0.Esta matriz se va deslizando por la imagene hasta detectar toda la linea de costa. cada n√∫mero 
#representa un pixel, y los de alrededor son sus p√≠xeles vecinos.
kernel = np.array([[1, 1, 1],
                   [1, 0, 1],
                   [1, 1, 1]])

kernel_4 = np.array([[0, 1, 0],
                     [1, 0, 1],
                     [0, 1, 0]])

# Lista para guardar todas las coordenadas de todas las fechas
all_coordinates = []

# Recorre totes les carpetes d‚Äôimatges
for root, dirs, files in os.walk(base_folder):   #root = ruta de la carpeta; dirs = lista de subcarpetas; files = lista de archivos en la carpeta
    if "waterbody.tif" in files:    #verifica que exista la carpeta
        waterbody_path = os.path.join(root, "waterbody.tif")    #construye la ruta al archivo
        print(f"Processant {waterbody_path}...")    

        #breakpoint()
        # Obre i llegeix el GeoTIFF
        with rasterio.open(waterbody_path) as src:  #abre el archivo en modo lectura
            out_image, out_transform = mask(src, polygon_geom, crop=True) #sirve para recortar la imagen
            waterbody = src.read(1) #coge la primera banda que tenga agua sabiendo que agua = 1; no agua = 0. 
            profile = src.profile
            transform = src.transform  # Guardamos la transformaci√≥n para coordenadas, cambia p√≠xeles a coordenadas reales

            profile.update({
                "height": out_image.shape[1],
                "width": out_image.shape[2],
                "transform": out_transform
            }) #sirve para actualizar los metadatos de las imagenes para poder recortarlo



        # CORNER CASE 1: Excluir bordes del AOI (3 p√≠xeles de cada lado), es decir de la parte de AOI elimina tres pixeles para que no
        #los confunda con tierra, simplemente no existen
        height, width = waterbody.shape
        border_mask = np.ones_like(waterbody, dtype=bool)
        border_mask[:3, :] = False        # Borde superior
        border_mask[-3:, :] = False       # Borde inferior  
        border_mask[:, :3] = False        # Borde izquierdo
        border_mask[:, -3:] = False       # Borde derecho
        
         # CORNER CASE 2: Detectar √°reas nubladas (patrones irregulares)
        
        matriz_zonas_agua, num_water_components = ndimage.label(waterbody == 1) #Encuentra zonas de agua, asigna un n√∫mero √∫nico a cada zona de agua
        water_component_sizes = np.bincount(matriz_zonas_agua.ravel()) #.ravel transforma la matriz en vector, 
                                                                        #bincount cuanta el numero de pixeles en cada zona(posicion 0 del vector son todos los pixeles de tierra)
        
        cloud_mask = np.ones_like(waterbody, dtype=bool)
        
        small_components = 0
        for label in range(1, num_water_components + 1): #recorre todas las zonas de agua, empezando en la 1, ya que la 0 es tierra
            if water_component_sizes[label] < 50:
                small_components += 1
                cloud_mask[matriz_zonas_agua == label] = False #Marca como probable nube todos los p√≠xeles de esa mancha peque√±a y los ignora
        
        cloud_ratio = small_components / max(1, num_water_components) #mira la proporcion de cuantas zonas son nubes en total
        if cloud_ratio > 0.3:
            print(f" Imagen posiblemente nublada ({cloud_ratio:.1%} componentes peque√±os)")
        
        # Detecta l√≠nia de costa
        neighbor_sum = convolve(waterbody, kernel, mode='constant', cval=0) #Lo multiplica por el kernel y si los vecinos que son agua son <8 
                                                                            #es una l√≠nea de costa, sino es mar.
        coastline = np.logical_and(waterbody == 1, neighbor_sum < 8).astype(np.uint8) #np.logical_and: combina ambas condiciones ‚Üí p√≠xeles de agua con al menos un vecino de tierra.
                                                                                    #.astype(np.uint8): convierte el resultado booleano a 0s y 1s,es decir, es o no es costa.

        # M√©todo 4-vecinos 
        neighbor_sum_4 = convolve(waterbody, kernel_4, mode='constant', cval=0)
        coastline_4 = np.logical_and(waterbody == 1, neighbor_sum_4 < 4).astype(np.uint8)
        
        # Comparar resultados
        pixels_8 = np.sum(coastline)
        pixels_4 = np.sum(coastline_4)
        
        print(f"   Comparaci√≥n m√©todos:")
        print(f"     - 8-vecinos: {pixels_8} p√≠xeles de costa")
        print(f"     - 4-vecinos: {pixels_4} p√≠xeles de costa")
        print(f"     - Diferencia: {abs(pixels_8 - pixels_4)} p√≠xeles")
        
        
        coastline = np.logical_and(coastline, border_mask).astype(np.uint8) #aplicar la eliminacion de los bordes AOI
        coastline = np.logical_and(coastline, cloud_mask).astype(np.uint8)  #aplicar lo de las nubes
        
        # Actualitza perfil per guardar
        profile.update(dtype=rasterio.uint8, count=1) #actualiza la forma de guardar los datos, por un lado count = 1 crea una sola banda(la de costa)
                                                        #por otro lado, dtype=rasterio.uint8 lo hace solo para ocupar menos espacio, ya que usamos 1 y 0 no floats

        # Ruta de sortida
        coastline_path = os.path.join(root, "coastline.tif") #ruta de salida para el archivo "coastline.tif" en la misma carpeta.

        # Guarda resultat
        with rasterio.open(coastline_path, 'w', **profile) as dst: 
            dst.write(coastline, 1)     #crea un nuevo archivo y escribe la coastline

        print(f"  ‚Üí L√≠nia de costa guardada a {coastline_path}")
        
        # üÜï EXPORTAR A GEOJSON
        # --------------------------------------------------
        print("  ‚Üí Exportant coordenades a GeoJSON...")
        
        # Troba els p√≠xels que s√≥n costa (valors = 1)
        y_indices, x_indices = np.where(coastline == 1) #np.where busca todos las coordenadas de los p√≠xeles coastline
        
        # Convierte los pixeles a coordenadas XY UTM Z31
        coordinates = []
        for x_pixel, y_pixel in zip(x_indices, y_indices):
            # Transforma coordenadass de p√≠xel a coordenadas UTM
            x_coord, y_coord = transform * (x_pixel, y_pixel)
            coordinates.append((x_coord, y_coord))
        
        
        # üÜï GUARDAR PARA CSV GLOBAL
        # Extraer fecha del nombre de carpeta o usar fecha actual
        folder_name = os.path.basename(root)
        
        # Intentar extraer fecha del nombre de carpeta
        try:
            # Si la carpeta tiene formato de fecha: "2024-01-15"
            date_str = folder_name
        except:
            # Si no, usar fecha de procesamiento
            date_str = datetime.now().strftime("%Y-%m-%d")
        
        
        # Crea GeoDataFrame
        gdf = gpd.GeoDataFrame({
            #'id': range(len(geometries)),  # ID √∫nic per a cada punt, sirve para darle un numero a cada pto
            'x': [coord[0] for coord in coordinates],  # Coordenada X
            'y': [coord[1] for coord in coordinates]   # Coordenada Y
        }, geometry=geometries, crs="EPSG:32631")  # directamente pone las coordenadas en UTM

        # Cambiar las coordenadas de longitud y latitud a XY UTM N31 (esto es por si las coordenadas est√°n en long/lat)
        #gdf_utm = gdf.to_crs("EPSG:32631")
        #gdf_utm["X_UTM"] = gdf_utm.geometry.x
        #gdf_utm["Y_UTM"] = gdf_utm.geometry.y

        # Ruta per al fitxer GeoJSON
        geojson_path_utm = os.path.join(root, "coastline_utm.geojson") #donde lo guardas y crea la ruta
        
        # Guarda com a GeoJSON
        gdf_utm.to_file(geojson_path_utm, driver='GeoJSON') #para guardarlo como un GEOJ
        
        print(f"  ‚Üí GeoJSON guardat a {geojson_path_utm}")
        print(f"  ‚Üí S'han exportat {len(coordinates)} punts de costa")

print("\n‚úîÔ∏è Processament complet.")


# üÜï GENERAR CSV GLOBAL CON TODAS LAS FECHAS
if all_coordinates:

    # Crear DataFrame con todas las coordenadas
    df_global = pd.DataFrame(all_coordinates)

   
    # Guardar CSV
    csv_path = os.path.join(base_folder, "coastline_coordinates_all_dates.csv")
    df_global.to_csv(csv_path, index=False)
    
    print(f"\nüìÑ CSV GLOBAL GENERADO:")
    print(f"   ‚Üí Archivo: {csv_path}")
    print(f"   ‚Üí Total puntos: {len(df_global)}")
    print(f"   ‚Üí Fechas √∫nicas: {df_global['Date'].nunique()}")
    print(f"   ‚Üí Columnas: {list(df_global.columns)}")
    
    # Mostrar primeras filas como ejemplo
    print(f"\nüìã Primeras filas del CSV:")
    print(df_global.head())
else:
    print("‚ö†Ô∏è No se encontraron coordenadas para generar el CSV")
