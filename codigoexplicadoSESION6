import os   #para trabjar con archivos, carpetas..
import rasterio
import numpy as np       #para trabajar con arreys num√©ricos
from scipy.ndimage import convolve #Importa la funci√≥n convolve de SciPy para aplicar filtros/convoluciones a imagenes
import geopandas as gpd
from shapely.geometry import Point
from datetime import datetime
import pandas as pd

# Carpeta on tens les imatges descarregades
base_folder = "./sentinel2_images4"

# Kernel per detectar canvis als ve√Øns (3x3 excloent el centre), nos permite detectar lo bordes. Lo multiplicas con matriz 3x3 desde que se detecta
# un agua, sabiendo que agua = 1 y no agua = 0.Esta matriz se va deslizando por la imagene hasta detectar toda la linea de costa. cada n√∫mero 
#representa un pixel, y los de alrededor son sus p√≠xeles vecinos.
kernel = np.array([[1, 1, 1],
                   [1, 0, 1],
                   [1, 1, 1]])

kernel_4 = np.array([[0, 1, 0],
                     [1, 0, 1],
                     [0, 1, 0]])

# Lista para guardar todas las coordenadas de todas las fechas
all_coordinates = []

# Recorre totes les carpetes d‚Äôimatges
for root, dirs, files in os.walk(base_folder):   #root = ruta de la carpeta; dirs = lista de subcarpetas; files = lista de archivos en la carpeta
    if "waterbody.tif" in files:    #verifica que exista la carpeta
        waterbody_path = os.path.join(root, "waterbody.tif")    #construye la ruta al archivo
        print(f"Processant {waterbody_path}...")    

        # Obre i llegeix el GeoTIFF
        with rasterio.open(waterbody_path) as src:  #abre el archivo en modo lectura
            waterbody = src.read(1) #coge la primera banda que tenga agua sabiendo que agua = 1; no agua = 0. 
            profile = src.profile
            transform = src.transform  # Guardamos la transformaci√≥n para coordenadas, cambia p√≠xeles a coordenadas reales

        # CORNER CASE 1: Excluir bordes del AOI (3 p√≠xeles de cada lado), es decir de la parte de AOI elimina tres pixeles para que no
        #los confunda con tierra, simplemente no existen
        height, width = waterbody.shape
        border_mask = np.ones_like(waterbody, dtype=bool)
        border_mask[:3, :] = False        # Borde superior
        border_mask[-3:, :] = False       # Borde inferior  
        border_mask[:, :3] = False        # Borde izquierdo
        border_mask[:, -3:] = False       # Borde derecho
        
         # CORNER CASE 2: Detectar √°reas nubladas (patrones irregulares)
        from scipy import ndimage
        
        matriz_zonas_agua, num_water_components = ndimage.label(waterbody == 1) #Encuentra zonas de agua, asigna un n√∫mero √∫nico a cada zona de agua
        water_component_sizes = np.bincount(matriz_zonas_agua.ravel()) #.ravel transforma la matriz en vector, 
                                                                        #bincount cuanta el numero de pixeles en cada zona(posicion 0 del vector son todos los pixeles de tierra)
        
        cloud_mask = np.ones_like(waterbody, dtype=bool)
        
        small_components = 0
        for label in range(1, num_water_components + 1): #recorre todas las zonas de agua, empezando en la 1, ya que la 0 es tierra
            if water_component_sizes[label] < 50:
                small_components += 1
                cloud_mask[matriz_zonas_agua == label] = False #Marca como probable nube todos los p√≠xeles de esa mancha peque√±a y los ignora
        
        cloud_ratio = small_components / max(1, num_water_components) #mira la proporcion de cuantas zonas son nubes en total
        if cloud_ratio > 0.3:
            print(f" Imagen posiblemente nublada ({cloud_ratio:.1%} componentes peque√±os)")
        
        # Detecta l√≠nia de costa
        neighbor_sum = convolve(waterbody, kernel, mode='constant', cval=0) #Lo multiplica por el kernel y si los vecinos que son agua son <8 
                                                                            #es una l√≠nea de costa, sino es mar.
        coastline = np.logical_and(waterbody == 1, neighbor_sum < 8).astype(np.uint8) #np.logical_and: combina ambas condiciones ‚Üí p√≠xeles de agua con al menos un vecino de tierra.
                                                                                    #.astype(np.uint8): convierte el resultado booleano a 0s y 1s,es decir, es o no es costa.

        # M√©todo 4-vecinos 
        neighbor_sum_4 = convolve(waterbody, kernel_4, mode='constant', cval=0)
        coastline_4 = np.logical_and(waterbody == 1, neighbor_sum_4 < 4).astype(np.uint8)
        
        # Comparar resultados
        pixels_8 = np.sum(coastline)
        pixels_4 = np.sum(coastline_4)
        
        print(f"   Comparaci√≥n m√©todos:")
        print(f"     - 8-vecinos: {pixels_8} p√≠xeles de costa")
        print(f"     - 4-vecinos: {pixels_4} p√≠xeles de costa")
        print(f"     - Diferencia: {abs(pixels_8 - pixels_4)} p√≠xeles")
        
        
        coastline = np.logical_and(coastline, border_mask).astype(np.uint8) #aplicar la eliminacion de los bordes AOI
        coastline = np.logical_and(coastline, cloud_mask).astype(np.uint8)  #aplicar lo de las nubes
        
        # Actualitza perfil per guardar
        profile.update(dtype=rasterio.uint8, count=1) #actualiza la forma de guardar los datos, por un lado count = 1 crea una sola banda(la de costa)
                                                        #por otro lado, dtype=rasterio.uint8 lo hace solo para ocupar menos espacio, ya que usamos 1 y 0 no floats

        # Ruta de sortida
        coastline_path = os.path.join(root, "coastline.tif") #ruta de salida para el archivo "coastline.tif" en la misma carpeta.

        # Guarda resultat
        with rasterio.open(coastline_path, 'w', **profile) as dst: 
            dst.write(coastline, 1)     #crea un nuevo archivo y escribe la coastline

        print(f"  ‚Üí L√≠nia de costa guardada a {coastline_path}")
        
        # üÜï EXPORTAR A GEOJSON
        # --------------------------------------------------
        print("  ‚Üí Exportant coordenades a GeoJSON...")
        
        # Troba els p√≠xels que s√≥n costa (valors = 1)
        y_indices, x_indices = np.where(coastline == 1) #np.where busca todos las coordenadas de los p√≠xeles coastline
        
        # Converteix p√≠xels a coordenades reals (lat, lon)
        coordinates = []
        for x_pixel, y_pixel in zip(x_indices, y_indices):
            # Transforma coordenades de p√≠xel a coordenades mundials (longitud y latitud)
            lon, lat = transform * (x_pixel, y_pixel)
            coordinates.append((lon, lat))
        
        
        # üÜï GUARDAR PARA CSV GLOBAL
        # Extraer fecha del nombre de carpeta o usar fecha actual
        folder_name = os.path.basename(root)
        
        # Intentar extraer fecha del nombre de carpeta
        try:
            # Si la carpeta tiene formato de fecha: "2024-01-15"
            date_str = folder_name
        except:
            # Si no, usar fecha de procesamiento
            date_str = datetime.now().strftime("%Y-%m-%d")
        
        # A√±adir todas las coordenadas con su fecha a la lista global
        for lon, lat in coordinates:
            all_coordinates.append({
                'X': lon,
                'Y': lat, 
                'Date': date_str
            })     
        
        # Crea geometries Point per a cada coordenada de costa
        geometries = [Point(lon, lat) for lon, lat in coordinates] #geometries = todos los ptos de costa que encontramos
        
        # Crea GeoDataFrame
        gdf = gpd.GeoDataFrame({
            #'id': range(len(geometries)),  # ID √∫nic per a cada punt, sirve para darle un numero a cada pto
            'x': [coord[0] for coord in coordinates],  # Longitud
            'y': [coord[1] for coord in coordinates]   # Latitud
        }, geometry=geometries, crs="EPSG:4326")  # lo aplica al sistema de coordenadas de google maps
        
        # Ruta per al fitxer GeoJSON
        geojson_path = os.path.join(root, "coastline.geojson") #donde lo guardas y crea la ruta
        
        # Guarda com a GeoJSON
        gdf.to_file(geojson_path, driver='GeoJSON') #para guardarlo como un GEOJ
        
        print(f"  ‚Üí GeoJSON guardat a {geojson_path}")
        print(f"  ‚Üí S'han exportat {len(coordinates)} punts de costa")

print("\n‚úîÔ∏è Processament complet.")


# üÜï GENERAR CSV GLOBAL CON TODAS LAS FECHAS
if all_coordinates:
    # Crear DataFrame con todas las coordenadas
    df_global = pd.DataFrame(all_coordinates)
    
    # Guardar CSV
    csv_path = os.path.join(base_folder, "coastline_coordinates_all_dates.csv")
    df_global.to_csv(csv_path, index=False)
    
    print(f"\nüìÑ CSV GLOBAL GENERADO:")
    print(f"   ‚Üí Archivo: {csv_path}")
    print(f"   ‚Üí Total puntos: {len(df_global)}")
    print(f"   ‚Üí Fechas √∫nicas: {df_global['Date'].nunique()}")
    print(f"   ‚Üí Columnas: {list(df_global.columns)}")
    
    # Mostrar primeras filas como ejemplo
    print(f"\nüìã Primeras filas del CSV:")
    print(df_global.head())
else:
    print("‚ö†Ô∏è No se encontraron coordenadas para generar el CSV")
